---
title: 数据库基础
excerpt: 
  <img class="lazy" width="100%" 
  data-original="https://tracerzzz.ltd/20180309152056989944519.png">整理了一些基础的数据知识，还有一些经常用到又经常忘记的知识点，以便平时查阅或者面试时用。
tags:
- 数据库
- mysql
date: 2016-11-05 11:22:11
categories:
- coding
---

![20180309152056989944519.png](https://tracerzzz.ltd/20180309152056989944519.png)

### 数据库三范式是什么?

 1第一范式就是无重复的列。

 2第二范式就是无重复的行

>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被唯一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。 员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是唯一的，因此每个员工可以被唯一区分。这个唯一属性列被称为主关键字或主键、主码。
第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。


3第三范式就是引用别的表的字段时，不能出现非主键字段。
第三范式（3NF）
>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在图3-2的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。

### 数据库表连接
连接一共分为内连接、外连接和交叉连接
#### 内连接
内连接(INNER JOIN)使用比较运算符进行表间某(些)列数据的比较操作，并列出这些表中与连接条件相匹配的数据行。
根据所使用的比较方式不同，内连接又分为等值连接、自然连接和不等连接三种。

内连接分三种：

##### 等值连接

等值连接：在连接条件中使用等于号(=)运算符比较被连接列的列值，其查询结果中列出被连接表中的所有列，包括其中的重复列。

##### 不等连接

不等连接：在连接条件使用除等于运算符以外的其它比较运算符比较被连接的列的列值。这些运算符包括>、>=、、!。

##### 自然连接

自然连接：在连接条件中使用等于(=)运算符比较被连接列的列值，但它使用选择列表指出查询结果集合中所包括的列，并删除连接表中的重复列。

*等值连接与自然连接的区别：*
1）**等值连接中不要求相等属性值的属性名相同**，而自然连接要求相等属性值的属性名必须相同，即两关系只有在同名属性才能进行自然连接。
2）**等值连接不将重复属性去掉，而自然连接去掉重复属性，也可以说，自然连接是去掉重复列的等值连接。**

#### 外连接
外连接分为左外连接(LEFT OUTER JOIN或LEFT JOIN)、右外连接(RIGHT OUTER JOIN或RIGHT JOIN)和全外连接(FULL OUTER JOIN或FULL JOIN)三种。
内连接查询时，返回查询结果集合中的仅是符合查询条件( WHERE 搜索条件或 HAVING 条件)和连接条件
的行。而采用外连接时，它返回到查询结果集合中的不仅包含符合连接条件的行，而且还包括左表(左外连接时)、右表(右外连接时)或两个边接表(全外连接)中的所有数据行。

如下面使用左外连接将论坛内容和作者信息连接起来： 
代码:SELECT a.*,b.* FROM `luntan` as a LEFT JOIN usertable as b
ON a.username=b.username下面使用全外连接将city表中的所有作者以及user表中的所有作者，以及他们所在的城市： 
代码:SELECT a.*,b.*
FROM city as a FULL OUTER JOIN user as b
ON a.username=b.username

#### 交叉连接
交叉连接不带WHERE 子句，它返回被连接的两个表所有数据行的笛卡尔积，返回到结果集合中的数
据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。
例，titles表中有6类图书，而publishers表中有8家出版社，则下列交叉连接检索到的记录数将等
于6*8=48行。 
代码:SELECT `type`,`pub_name`
FROM `titles` CROSS JOIN `publishers`
ORDER BY `type`

### Group by与having理解
**group by 有一个原则,就是 select 后面的所有列中,没有使用聚合函数的列,必须出现在 group by 后面（重要）**

having子句与where有相似之处但也有区别,都是设定条件的语句。
在查询过程中聚合语句(sum,min,max,avg,count)要比having子句优先执行.而where子句在查询过程中执行优先级别优先于聚合语句(sum,min,max,avg,count)。

结论：
1.WHERE 子句用来筛选 FROM 子句中指定的操作所产生的行。
2.GROUP BY 子句用来分组 WHERE 子句的输出。
3.HAVING 子句用来从分组的结果中筛选行。

